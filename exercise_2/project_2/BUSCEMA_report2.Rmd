---
title: "High Performance Computing - Exercise 2 (C)"
subtitle: "Mandelbot Set using MPI + OpenMP"
author: "Andrea Buscema"
date: "30/05/2024"
output: pdf_document
header-includes:
  - \usepackage{wrapfig}
  - \usepackage{graphicx}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this report, will be discussed the results of the second exercise of the High Performance Computing assignment. The objective of this exercise is to implement the Mandelbrot Set using MPI and OpenMP, obtaining a single pgm image as output, and analysing the scalability of the implementation:

-   OMP scaling: run with a single MPI task and increase the number of OMP threads;
-   MPI scaling: run with a single OMP thread per MPI task and increase the number of MPI tasks;
-   Hybrid scaling (such an extra analysis - not required for the assignment): run for different combinations of MPI and OMP threads.

As for the first exercise/assignment, the project was implemented to be used in the ORFEO HPC Cluster, using THIN nodes. The project was implemented in C language, using the MPI and OpenMP libraries, SLURM for job submission (file .sbatch), and Python for data analysis and plotting.

## Replication of the project

Since the ORFEO Cluster is not available for external users, the project can be replicated in a local machine or in another cluster and be represented considering a general usage for most of the HPC systems with same characteristics of the ORFEO Cluster. For extra information about the ORFEO Cluster, please refer to the [ORFEO Documentation](https://orfeo-doc.areasciencepark.it/HPC/).

## Description of the project

The Mandelbrot set is a fascinating and well-known construct in complex dynamics, generated by iterating a simple complex function on the complex plane $\mathbb{C}$. Specifically, this set is defined using the function $f_c(z)$ given by:

$$f_c(z) = z^2 + c$$

Here, *c* is a complex number $c = x + iy$, and the iteration starts with $z = 0$, producing a series of complex numbers $z_0, z_1, z_2, ...$ defined by:

$$z_0 = 0, z_1 = f_c(0), z_2 = f_c(z_1), \space \dots \space , z_n = f_c^n(z_{n-1})$$

The Mandelbrot set $\mathcal{M}$ consists of all complex points *c* for which this series remains bounded. A key characteristic of the Mandelbrot set is that if any element $z_i$ in the series has a magnitude greater that 2, the series will eventually become unbounded. Therefore, a point *c* is considered to be in the Mandelbrot set $\mathcal{M}$ if :

$$|z_n| < 2 \space \text{for all} \space n \leq I_{max}$$

where $I_{max}$ is a parameter that sets the maximum number of iterations, balancing the accuracy of the calculation with computational cost.

To visualise the Mandelbrot set, we can generate an image representing a portion of the complex plane. This portion is bounded by two corners: the bottom-left corner $c_L = x_L + iy_L$, and the top right corner $c_R = x_R + iy_R$. the image is composed on $n_x \times n_y$ pixels, each corresponding to a point $c_i$ in the complex plane:

$$c_i = (x_L + \Delta x) + i(y_L + \Delta y)$$

where:

$$\Delta x = \frac{x_R - x_L}{n_x}$$

and

$$\Delta y = \frac{y_R - y_L}{n_y}$$

We define a 2D matrix $M$ of integers where each entry $[j][i]$ corresponds to a pixel in the image. The value of each pixel is determined by whether the corresponding point *c* belongs to the Mandelbrot set $\mathcal{M}$. If *c* belongs to $\mathcal{M}$, the pixel value is 0. Otherwise, the pixel value is the iteration count $n$ at which the magnitude of $z_n(c)$ exceeds 2, up to a maximum value of $I_{max}$.

This problem is inherently parallelisable since each point $c_i$ can be computed independently. However, distributing the computational load evenly among concurrent processes or threads can be challenging due to the varying complexity of different regions of the Mandelbrot set. Inner points of $\mathcal{M}$ require more iterations to determine their membership, whereas outer points are computationally simpler. The bundary between these regions, the "frontier", is particularly complex and requires careful consideration to avoid load imbalance in parallel implementations.

> **Note 1**: Mandelbrot set lives roughly in the circular region centered on $(-0.75, 0)$ with a radius of $\sim 2$.

> **Note 2:** the multiplication of 2 complex numbers is defined as $(x_1 + iy_1)\,\times\,(x_2+iy_2) = (x_1x_2 - y_1y_2) + i(x_1y_2+x_2y_1)$

With those notes in mind, we can expand basic Mandelbrot set computation to more accurately explore regions within the Mandelbrot set and potentially implement functionality that considers complex number multiplication.

## Reason behind the choice of this project

Implementing the Mandelbrot set calculation project is intriguing for several reasons. Firstly, it allows for the visualization of complex dynamics, providing a fascinating insight into fractal geometry and iterative processes involving complex numbers. The computational challenge of generating high-resolution images of the Mandelbrot set requires significant computational power, making it an excellent problem for exploring computational methods and performance optimization.

The Mandelbrot set problem is inherently parallelisable since the calculation for each point in the complex plane is independent of others. This characteristic makes it ideal for testing parallel computing techniques. By utilizing a hybrid approach combining MPI (Message Passing Interface) and OpenMP (Open Multi-Processing), we can leverage the strengths of both distributed and shared memory architectures. MPI is used to handle communication between nodes in a cluster, while OpenMP manages parallelism within each node. This hybrid parallelism approach is well-suited for high-performance computing (HPC) clusters.

Moreover, by implementing and testing the Mandelbrot set computation on an HPC cluster, we can gather valuable performance metrics such as speedup, efficiency, and scalability. These metrics provide insights into how well the hybrid MPI-OpenMP approach performs under different configurations and workloads. Scalability testing can be extensively performed by varying the number of nodes (using MPI) and the number of threads per node (using OpenMP). This analysis helps identify bottlenecks and optimize performance for large-scale computations.

The techniques and insights gained from this project have broader applications beyond fractal geometry. They are relevant to other scientific and engineering problems that require high-performance computing, such as climate modeling, molecular dynamics, and large-scale data analysis. Understanding how to efficiently utilize HPC resources is crucial for advancing computational capabilities in these fields. It is a practical and visually engaging way to test and improve computational techniques in a high-performance environment, with implications for a wide range of real-world applications.

## Starting point

Since the Mandelbrot set resides within a circle centered around $(-0.75, 0)$ with a radius of $\sim 2$, we can set our program to generate a grid of points around this region to visualize the set. To do this efficiently and effectively, it is possible to start by computing a range of points that covers this area.

**Implementation steps**:

1.  Setup a grid: Defining a grid of complex nubers centered around $(-0.75, 0)$ with a radius of $\sim 2$.

2.  terating over each point: For each point on this grid, it is possible to determine whether it belongs to the Mandelbrot set using the iterative method.

For the first test, it was implemented a simple script where the program writes the output to a file in txt format, in ASCII mode.

Inside `local_test` folder, it was created a simple script to generate the Mandelbrot set in a txt file, then implemented to create a pgm image with different sizes and resolutions. This was done to test initial implementations and to understand the structure of the Mandelbrot set.
